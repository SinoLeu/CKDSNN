
import torch
from torch.utils.data import Dataset, DataLoader
from tqdm import tqdm
from torch.utils.data import DataLoader
import numpy as np

class GradCamDataset_Load(Dataset):
    def __init__(self, images, labels, gradcam_results,transform):
        self.images = images
        self.labels = labels
        self.gradcam_results = gradcam_results
        self.transform = transform
        # self.norm_transform = norm_transform

    def __len__(self):
        return len(self.images)

    def __getitem__(self, idx):
        image = self.images[idx].astype(np.float32)
        label = self.labels[idx]
        # gradcam = torch.tensor(self.gradcam_results[idx], dtype=torch.float32)
        gradcam = self.gradcam_results[idx].astype(np.float32)
        # print(image.shape)
        # image = np.transpose(image, (1, 2, 0))  # Now (256, 256, 3)
        # print(image.shape)
        # if image.ndim == 2:
        #     image = image.unsqueeze(0)
        # elif image.ndim == 3 and image.shape[-1] in [1, 3]:
        #     image = image.permute(2, 0, 1)

        # if self.transform is not None:
        #     image = self.transform(image)
            # gradcam = self.transform(gradcam)
        # if self.normalize:
        #     image = transforms.Normalize(mean=self.mean, std=self.std)(image)

        return {
            'image': image,
            'label': torch.tensor(label, dtype=torch.long),
            'gradcam': gradcam
        }

    # def __getitem__(self, idx):
    #     if image.ndim == 2:
    #         image = image.unsqueeze(0)
    #     elif image.ndim == 3 and image.shape[-1] in [1, 3]:
    #         image = image.permute(2, 0, 1)
        
    #     if self.transform is not None:
    #         image = self.transform(self.images[idx])
    #     else:
    #         image = torch.tensor(self.images[idx])
    #     return {
    #         'image': image,
    #         'label': self.labels[idx],
    #         'gradcam': torch.tensor(self.gradcam_results[idx])
    #     }

class GradCamDataset(Dataset):
    def __init__(self, original_dataset, gradcam_results):
        """
        Custom dataset that combines the original dataset with Grad-CAM results.

        Args:
            original_dataset (Dataset): The original PyTorch dataset (e.g., CIFAR-10).
            gradcam_results (list): A list of Grad-CAM results generated by `generate_gradcam_results`.
        """
        self.original_dataset = original_dataset
        self.gradcam_results = gradcam_results

    def __len__(self):
        return len(self.original_dataset)

    def __getitem__(self, idx):
        # Get the original dataset sample (image and label)
        image, label = self.original_dataset[idx]

        # Get the Grad-CAM results for the same index
        gradcam_result = self.gradcam_results[idx]

        # Return both the original sample and the Grad-CAM result
        return {
            'image': image,
            'label': label,
            'gradcam': gradcam_result
        }


def generate_gradcam_results(train_dataset, ann_model, device, batch_size=64, is_resnet=False, cam_compute='GradCAMPlusPlus'):
    """
    Generate Grad-CAM results for a dataset using a specified CAM method.

    Parameters:
    - train_dataset: Dataset to compute Grad-CAM results.
    - ann_model: The model used for Grad-CAM computation.
    - device: The device to run the computation on (e.g., 'cuda' or 'cpu').
    - batch_size: Batch size for data loading.
    - is_resnet: Boolean indicating whether the model is a ResNet.
    - cam_compute: The CAM computation method ('GradCAM', 'GradCAMPlusPlus', 'EigenCAM').

    Returns:
    - save_list: List of dictionaries containing Grad-CAM results.
    """
    from pytorch_grad_cam import GradCAM, GradCAMPlusPlus, EigenCAM,LayerCAM
    from pytorch_grad_cam.utils.model_targets import ClassifierOutputTarget
    from torch.utils.data import DataLoader
    from tqdm import tqdm

    # Map cam_compute to the corresponding CAM class
    cam_classes = {
        'GradCAM': GradCAM,
        'GradCAMPlusPlus': GradCAMPlusPlus,
        'EigenCAM': EigenCAM,
        'LayerCAM': LayerCAM
    }

    if cam_compute not in cam_classes:
        raise ValueError(f"Unsupported cam_compute value: {cam_compute}. Choose from {list(cam_classes.keys())}")

    CAMClass = cam_classes[cam_compute]

    save_list = []
    dataloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=False)

    for batch_idx, (inputs, labels) in enumerate(tqdm(dataloader, desc=f"Generating {cam_compute}", leave=False)):
        # Move inputs and labels to the specified device
        inputs, labels = inputs.to(device), labels.to(device)
        targets = [ClassifierOutputTarget(label.item()) for label in labels]

        # Define target layers based on the model type
        if is_resnet:
            target_layers = [ann_model.layer3]
        else:
            target_layers = [ann_model.layers[-1]]

        # Apply the selected CAM method on each layer
        grayscale_cams = []
        for target_layer in target_layers:
            with CAMClass(model=ann_model, target_layers=[target_layer]) as cam:
                cam_results = torch.from_numpy(cam(input_tensor=inputs, targets=targets))
                grayscale_cams.append(cam_results)

        # Append Grad-CAM results for the batch to save_list
        for idx in range(inputs.size(0)):
            save_list.append({
                'cams': grayscale_cams[0][idx],
                'idx': batch_idx * batch_size + idx
            })

    return save_list

